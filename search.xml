<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Promise笔记</title>
      <link href="/2022/10/24/Promise/"/>
      <url>/2022/10/24/Promise/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise笔记"><a href="#Promise笔记" class="headerlink" title="Promise笔记"></a>Promise笔记</h1><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><ul><li>fs 文件操作<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFile</span>(<span class="string">&#x27;./index.html&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li>数据库操作</li><li>Ajax<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">get</span>(<span class="string">&#x27;/server&#x27;</span>,<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li>定时器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Promise的状态改变"><a href="#Promise的状态改变" class="headerlink" title="Promise的状态改变"></a>Promise的状态改变</h2><p>实例对象中的一个属性 [PromiseState]</p><ul><li>pending 未决定的</li><li>resolved / fullfilled 成功</li><li>rejected 失败</li></ul><ol><li>pending 变为 resolved</li><li>pending 变为 rejected</li></ol><blockquote><p>说明：只有这两种状态，且一个 promise 对象只能改变一次<br>      无论变为成功还是失败，都会有一个结果数据<br>      成功的结果数据一般称为 value，失败的结果数据一般称为 reason</p></blockquote><h2 id="Promise-对象的值"><a href="#Promise-对象的值" class="headerlink" title="Promise 对象的值"></a>Promise 对象的值</h2><p>实例对象中的另一个属性 [PromiseResult]<br>保存着异步任务 [成功/失败] 的结果</p><ul><li>resolve</li><li>reject</li></ul><h2 id="Promise-Api"><a href="#Promise-Api" class="headerlink" title="Promise  Api"></a>Promise  Api</h2><ol><li><p>Promise 构造函数: Promise(executor){}</p><ol><li>executor 函数： 执行器 (resolve,reject)=&gt;{}</li><li>resolve 函数：内部定义成功时调用的函数 value=&gt;{}</li><li>reject 函数：内部定义失败时调用的函数 reason=&gt;{}<blockquote><p>说明：executor会在Promise内部立即同步调用，异步操作在执行器中执行</p></blockquote></li></ol></li><li><p>Promise.prototype.then 方法：(onResolved,onRejected)=&gt;{}</p><ol><li>onResolved函数：成功的回调 value=&gt;{}</li><li>onRejected函数：失败的回调 reason=&gt;{}<blockquote><p>说明：指定用于得到成功value的成功回调和用于得到失败回调返回一个新的promise对象</p></blockquote></li></ol></li><li><p>Promise.prototype.catch 方法：(onRejected)=&gt;{}<br>onRejected函数：失败的回调 reason=&gt;{}</p></li><li><p>Promise.resolve 方法：(value)=&gt;{}<br>value: 成功的数据或promise 对象</p><ol><li>如果传入的参数为：非Promise类型的对象，则返回的结果为成功的promise对象</li><li>如果传入的参数为：Promise对象，则参数的结果决定了 resolve 的结果<blockquote><p>说明：返回一个成功/失败的promise对象</p></blockquote></li></ol></li><li><p>Promise.reject 方法：(reason)=&gt;{}<br>reason: 失败的原因</p><blockquote><p>说明：返回一个失败的promise对象</p></blockquote></li><li><p>Promise.all 方法：(promises)={}<br>promises：包含 n个 promise 的数组</p><blockquote><p>说明：返回一个新的promise，只有所有的promise都成功才成功，只要有一个失败了就直接失败</p></blockquote></li><li><p>Promise.race 方法：(promises)={}<br> promises：包含 n个 promise 的数组</p><blockquote><p>说明：返回一个新的promise，第一个完成的promise的结果状态就是最终的结果状态</p></blockquote></li></ol><h2 id="Promise-的几个关键问题"><a href="#Promise-的几个关键问题" class="headerlink" title="Promise 的几个关键问题"></a>Promise 的几个关键问题</h2><ol><li><p>如何改变promise的状态？</p><ol><li>resolve(value)：如果当前是 pending 就会变为 resolved</li><li>reject(reason)：如果当前是 pending 就会变为 rejected</li><li>抛出异常(throw)：如果当前是 pending 就会变为 rejected</li></ol></li><li><p>一个promise指定多个成功/失败回调函数，都会调用吗？<br>当 promise 改变为对应状态时都会调用</p></li><li><p>改变promise状态和指定回调函数谁先谁后？</p><ol><li>都有可能，正常情况下是先指定回调再改变状态，但也可以先改变状态再指定回调</li><li>如何先改状态再指定回调？<br>(1). 在执行器中直接调用 resolve()/reject()<br>(2). 延迟更长时间才调用then()</li><li>什么时候才能得到数据？<br>(1). 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据<br>(2). 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</li></ol></li><li><p>Promise.then()返回的新 promise 的结果状态由什么决定？</p><ol><li>简单表达：由 then()指定的回调函数执行的结果决定</li><li>详细描述:<br>(1). 如果抛出异常，新promise变为rejected，reason为抛出对的异常<br>(2). 如果返回的是非promise的任意值，新promise变为resolved，value为返回值<br>(3). 如果返回的是另一个promise，此promise的结果就会成为新promise的结果</li></ol></li><li><p>Promise 如何串连多个操作任务？</p><ol><li>promise 的 then()返回一个新的 promise ，可以开成 then()的链式调用</li><li>通过 then 的链式调用串连多个同步/异步任务</li></ol></li><li><p>Promise异常穿透？</p><ol><li>当使用 promise 的 then 链式调用时，可以在最后指定失败的回调</li><li>前面任何操作出了异常，都会传到最后失败的回调中处理</li></ol></li><li><p>中断 promise 链？</p><pre><code> 有且只有一个方式： `return new Promise(()=&gt;&#123;&#125;)`</code></pre><ol><li>当使用 promise 的then 链式调用时，在中间中断，不再调用后面的回调函数</li><li>办法：在回调函数中返回一个pending 状态的 promise对象</li></ol></li></ol><h2 id="async-与-await"><a href="#async-与-await" class="headerlink" title="async 与 await"></a>async 与 await</h2><ol><li><p>async 函数</p><ol><li>函数的返回值为 promise 对象</li><li>promise 对象的结果由 async 函数执行的返回值决定</li></ol></li><li><p>await 表达式</p><ol><li>await 右侧的表达式一般为 promise 对象，但也可以是其他的值</li><li>如果表达式是 promise 对象，await 返回的是promise成功的值</li><li>如果表达式是其他值，直接将此值作为 await 的返回值<blockquote><p>注意：<br>1.await 必须写在 async 函数中，但async函数中可以没有 await<br>2.如果 await 的promise 失败了，就会抛出异常，需要通过try…catch捕获处理</p></blockquote></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git 常用命令</title>
      <link href="/2022/10/24/gir%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/10/24/gir%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr><tr><td>git reset –hard HEAD^</td><td>回退一个版本</td></tr></tbody></table><h2 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git branch -r</td><td>列出所有远程分支</td></tr><tr><td>git branch -d 分支名</td><td>删除分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git checkout -b 分支名</td><td>新建一个分支并切换到该分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr><tr><td>git branch -dr [remote/branch]</td><td>删除远程分支</td></tr><tr><td>git push origin –delete 分支名</td><td>删除远程分支</td></tr></tbody></table><h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><h2 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h2><pre><code>ssh-keygen -t rsa -C 邮箱地址</code></pre><h2 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>cd</td><td>改变目录</td></tr><tr><td>cd ..</td><td>回退到上一个目录，直接cd进入默认目录</td></tr><tr><td>pwd</td><td>显示当前所在的目录路径</td></tr><tr><td>ls(ll)</td><td>都是列出当前目录中的所有文件，只不过ll列出的内容更为详细</td></tr><tr><td>touch</td><td>新建一个文件如touch index.js就会在当前目录下新建一个index.js文件</td></tr><tr><td>rm</td><td>删除一个文件,rm index.js 就会把index.js文件删除</td></tr><tr><td>mkdir</td><td>新建一个目录，就是新建一个文件夹</td></tr><tr><td>rm -r</td><td>删除一个文件夹, rm -r src,删除src目录</td></tr><tr><td>mv</td><td>移动文件，mv index.html src， index.html是我们要移动的文件, src是目标文件夹</td></tr><tr><td>reset</td><td>重新初始化终端/清屏</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>history</td><td>查看命令历史</td></tr><tr><td>help</td><td>帮助</td></tr><tr><td>exit</td><td>退出</td></tr><tr><td>#</td><td>表示注释</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
