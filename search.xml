<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue3快速上手</title>
      <link href="/2022/11/09/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2022/11/09/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" /><h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li>实现原理: <ul><li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li><li>通过Reflect（反射）:  对源对象的属性进行操作。</li><li>MDN文档中描述的Proxy与Reflect：<ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line"><span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li> ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li> reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li> 备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li> ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li> reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li> ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li> reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li>setup执行的时机<ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li>setup的参数<ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div><p>1</p><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p>类似于vue2.x中的mixin。</p></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</li><li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li><li>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</li></ul><ul><li>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></li></ul><h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Demo&#x27;,</span><br><span class="line">setup()&#123;</span><br><span class="line">// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">//自定义一个myRef</span><br><span class="line">function myRef(value,delay)&#123;</span><br><span class="line">let timer</span><br><span class="line">//通过customRef去实现自定义</span><br><span class="line">return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">return&#123;</span><br><span class="line">get()&#123;</span><br><span class="line">track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">return value</span><br><span class="line">&#125;,</span><br><span class="line">set(newValue)&#123;</span><br><span class="line">clearTimeout(timer)</span><br><span class="line">timer = setTimeout(()=&gt;&#123;</span><br><span class="line">value = newValue</span><br><span class="line">trigger() //告诉Vue去更新界面</span><br><span class="line">&#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">return &#123;</span><br><span class="line">keyword</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" /><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">&lt;Suspense&gt;</span><br><span class="line">&lt;template v-slot:default&gt;</span><br><span class="line">&lt;Child/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-slot:fallback&gt;</span><br><span class="line">&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue2基础笔记</title>
      <link href="/2022/11/09/vue2_%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/09/vue2_%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="vue2基础笔记"><a href="#vue2基础笔记" class="headerlink" title="vue2基础笔记"></a>vue2基础笔记</h1><h2 id="初始vue"><a href="#初始vue" class="headerlink" title="初始vue"></a>初始vue</h2><ol><li>想让Vue工作，就必须创建一个Vue实例，且要传入 一个配置对象；  </li><li>root容器里的代码依然符合html规范，只不过混入 了一些特殊的Vue语法；  </li><li>root容器里的代码被称为【Vue模板】；  </li><li>Vue实例和容器是一一对应的；  </li><li>真实开发中只有一个Vue实例，并且会配合着组件一 起使用；  </li><li>中的xxx要写js表达式，且xxx可以自动读 取到data中的所有属性；  </li><li>一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；  </li></ol><p>注意区分：js表达式 和 js代码(语句)</p><pre><code>    1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：                (1). a                (2). a+b                (3). demo(1)                (4). x === y ? &#39;a&#39; : &#39;b&#39;    2.js代码(语句)                (1). if()&#123;&#125;                (2). for()&#123;&#125;</code></pre><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>Vue模板语法有2大类：</p><ol><li>插值语法：  </li></ol><ul><li>功能：用于解析标签体内容。  </li><li>写法：，xxx是js表达式，且可以直接读取到data中的所有属性。</li></ul><ol start="2"><li>指令语法：</li></ol><ul><li>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。</li><li>举例：v-bind:href=”xxx” 或  简写为 :href=”xxx”，xxx同样要写js表达式，<pre><code>                               且可以直接读取到data中的所有属性。</code></pre><blockquote><p>备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</p></blockquote></li></ul><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>Vue中有2种数据绑定的方式： </p><ol><li>单向绑定(v-bind)：数据只能从data流向页面。</li><li>双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。<blockquote><p>备注：  </p><pre><code> 1. 双向绑定一般都应用在表单类元素上（如：input、select等）      2. v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</code></pre></blockquote></li></ol><h2 id="el与data的两种写法"><a href="#el与data的两种写法" class="headerlink" title="el与data的两种写法"></a>el与data的两种写法</h2><p>data与el的2种写法</p><ol><li>el有2种写法:<br> (1). new Vue时候配置el属性。<br> (2). 先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</li><li>data有2种写法:<br> (1).对象式<br> (2).函数式<br> 如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</li><li>一个重要的原则：<br> 由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</li></ol><h2 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h2><ol><li>MVVM模型<ol><li>M：模型(Model) ：data中的数据</li><li>V：视图(View) ：模板代码</li><li>VM：视图模型(ViewModel)：Vue实例</li></ol></li><li>观察发现：<ol><li>data中所有的属性，最后都出现在了vm身上。</li><li>vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</li></ol></li></ol><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><p>数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>:<span class="number">100</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">y</span>:<span class="number">200</span>&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj2,<span class="string">&#x27;x&#x27;</span>,&#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> obj.<span class="property">x</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">obj.<span class="property">x</span> = value</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>Vue中的数据代理：<br> 通过vm对象来代理data对象中属性的操作（读/写）</li><li>Vue中数据代理的好处：<br> 更加方便的操作data中的数据</li><li>基本原理：<ul><li>通过Object.defineProperty()把data对象中所有属性添加到vm上。</li><li>为每一个添加到vm上的属性，都指定一个getter/setter。</li><li>在getter/setter内部去操作（读/写）data中对应的属性。</li></ul></li></ol><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ol><li><p>事件的基本使用：</p><ol><li>使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</li><li>事件的回调需要配置在methods对象中，最终会在vm上；</li><li>methods中配置的函数，不要用箭头函数！否则this就不是vm了；</li><li>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</li><li>@click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传参；</li></ol></li><li><p>Vue中的事件修饰符：</p><ol><li>prevent：阻止默认事件（常用）；</li><li>stop：阻止事件冒泡（常用）；</li><li>once：事件只触发一次（常用）；</li><li>capture：使用事件的捕获模式；</li><li>self：只有event.target是当前操作的元素时才触发事件；</li><li>passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</li></ol></li><li><p>Vue中的键盘事件：</p><ol><li>Vue中常用的按键别名： 回车 =&gt; enter<br> 删除 =&gt; delete (捕获“删除”和“退格”键)<br> 退出 =&gt; esc<br> 空格 =&gt; space<br> 换行 =&gt; tab (特殊，必须配合keydown去使用)<br> 上 =&gt; up<br> 下 =&gt; down<br> 左 =&gt; left<br> 右 =&gt; right  </li><li>Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</li><li>系统修饰键（用法特殊）：ctrl、alt、shift、meta<br> (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。<br> (2).配合keydown使用：正常触发事件。</li><li>也可以使用keyCode去指定具体的按键（不推荐）</li><li>Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</li></ol></li></ol><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><ol><li>定义：要用的属性不存在，要通过已有属性计算得来。</li><li>原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</li><li>get函数什么时候执行？ (1). 初次读取时会执行一次。<br> (2). 当依赖的数据发生改变时会被再次调用。</li><li>优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</li><li>备注：<ol><li>计算属性最终会出现在vm上，直接读取使用即可。</li><li>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</li></ol></li></ol><h2 id="监视属性watch"><a href="#监视属性watch" class="headerlink" title="监视属性watch"></a>监视属性watch</h2><ol><li><p>当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p></li><li><p>监视的属性必须存在，才能进行监视！！</p></li><li><p>监视的两种写法：</p><p> (1).new Vue时传入watch配置<br> (2).通过vm.$watch监视</p></li><li><p>深度监视：</p><p> (1).Vue中的watch默认不监测对象内部值的改变（一层）。<br> (2).配置deep:true可以监测对象内部值改变（多层）。</p><blockquote><p>备注：<br> (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！<br> (2).使用watch时根据数据的具体结构，决定是否采用深度监视。</p></blockquote></li></ol><h2 id="computed和watch之间的区别："><a href="#computed和watch之间的区别：" class="headerlink" title="computed和watch之间的区别："></a>computed和watch之间的区别：</h2><pre><code>1.computed能完成的功能，watch都可以完成。  2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。  两个重要的小原则：  1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数）,  最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</code></pre><h2 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a>绑定样式</h2><ol><li><p>class样式:</p><p>写法:class=”xxx” xxx可以是字符串、对象、数组。</p><pre><code> 字符串写法适用于：类名不确定，要动态获取。 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</code></pre></li><li><p>style样式:</p><pre><code> :style=&quot;&#123;fontSize: xxx&#125;&quot;其中xxx是动态值。 :style=&quot;[a,b]&quot;其中a、b是样式对象。</code></pre></li></ol><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ol><li><p>v-if<br> 写法：</p><pre><code> (1) v-if=&quot;表达式&quot;  (2) v-else-if=&quot;表达式&quot; (3) v-else=&quot;表达式&quot;</code></pre><p> 适用于：切换频率较低的场景。<br> 特点：不展示的DOM元素直接被移除。<br> 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p></li><li><p>v-show<br> 写法：</p><pre><code> v-show=&quot;表达式&quot;</code></pre><p> 适用于：切换频率较高的场景。<br> 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p></li></ol><blockquote><p>备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p></blockquote><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><ol><li><p>基本列表：</p><p> v-for指令: </p><pre><code> 1. 用于展示列表数据 2. 语法：v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot; 3. 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</code></pre></li><li><p>key的原理：</p><p> 面试题：react、vue中的key有什么作用？（key的内部原理）</p><ol><li><p>虚拟DOM中key的作用：</p><p> key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,<br> 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p></li><li><p>对比规则：</p><p> (1). 旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><pre><code> ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</code></pre><p> (2). 旧虚拟DOM中未找到与新虚拟DOM相同的key</p><pre><code> 创建新的真实DOM，随后渲染到到页面。    </code></pre></li><li><p>用index作为key可能会引发的问题：</p><ol><li>若对数据进行：逆序添加、逆序删除等破坏顺序操作:<pre><code>         会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</code></pre></li><li>如果结构中还包含输入类的DOM：<pre><code>         会产生错误DOM更新 ==&gt; 界面有问题。</code></pre></li></ol></li><li><p>开发中如何选择key?:</p><ol><li>最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</li><li>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br> 使用index作为key是没有问题的。</li></ol></li></ol></li></ol><h2 id="Vue监视数据的原理"><a href="#Vue监视数据的原理" class="headerlink" title="Vue监视数据的原理"></a>Vue监视数据的原理</h2><ol><li><p>vue会监视data中所有层次的数据。</p></li><li><p>如何监测对象中的数据？</p><p> 通过setter实现监视，且要在new Vue时就传入要监测的数据。  </p><pre><code> (1).对象中后追加的属性，Vue默认不做响应式处理   (2).如需给后添加的属性做响应式，请使用如下API：       Vue.set(target，propertyName/index，value) 或      vm.$set(target，propertyName/index，value)</code></pre></li><li><p>如何监测数组中的数据？</p><p> 通过包裹数组更新元素的方法实现，本质就是做了两件事:</p><pre><code> (1).调用原生对应的方法对数组进行更新。   (2).重新解析模板，进而更新页面。</code></pre></li><li><p>在Vue修改数组中的某个元素一定要用如下方法：</p><ol><li>使用这些API: push()、pop()、shift()、unshift()、splice()、sort()、reverse()</li><li>Vue.set() 或 vm.$set()</li></ol></li></ol><blockquote><p>特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p></blockquote><h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><p>若：<code>&lt;input type=&quot;text&quot;/&gt;</code>则v-model收集的是value值，用户输入的就是value值。 </p><p>若：<code>&lt;input type=&quot;radio&quot;/&gt;</code>则v-model收集的是value值，且要给标签配置value值。  </p><p>若：<code>&lt;input type=&quot;checkbox&quot;/&gt;</code><br>        1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>        2.配置input的value属性:<br>                (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>                (2)v-model的初始值是数组，那么收集的的就是value组成的数组</p><blockquote><p>备注：v-model的三个修饰符：<br>                lazy：失去焦点再收集数据<br>                number：输入字符串转为有效的数字<br>                trim：输入首尾空格过滤</p></blockquote><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p><p>语法：</p><pre><code>1. 注册过滤器：Vue.filter(name,callback) 或 new Vue&#123;filters:&#123;&#125;&#125;2. 使用过滤器：&#123;&#123; xxx | 过滤器名&#125;&#125;  或  v-bind:属性 = &quot;xxx | 过滤器名&quot;3. </code></pre><blockquote><p>备注：<br>    1. 过滤器也可以接收额外参数、多个过滤器也可以串联<br>    2. 并没有改变原本的数据, 是产生新的对应的数据</p></blockquote><h2 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h2><ol><li><p>常用指令：</p><pre><code> v-bind    : 单向绑定解析表达式, 可简写为 :xxx v-model    : 双向数据绑定 v-for      : 遍历数组/对象/字符串 v-on       : 绑定事件监听, 可简写为@ v-if          : 条件渲染（动态控制节点是否存存在） v-else     : 条件渲染（动态控制节点是否存存在） v-show     : 条件渲染 (动态控制节点是否展示)</code></pre></li><li><p>v-text指令：</p><pre><code> 1.作用：向其所在的节点中渲染文本内容。 2.与插值语法的区别：v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。</code></pre></li><li><p>v-html指令：</p><pre><code> 1.作用：向指定节点中渲染包含html结构的内容。 2.与插值语法的区别：     (1).v-html会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125;则不会。     (2).v-html可以识别html结构。 3.严重注意：v-html有安全性问题！！！！     (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。     (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</code></pre></li><li><p>v-cloak指令（没有值）：</p><pre><code> 1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。 2.使用css配合v-cloak可以解决网速慢时页面展示出&#123;&#123;xxx&#125;&#125;的问题。</code></pre></li><li><p>v-once指令：</p><pre><code> 1.v-once所在节点在初次动态渲染后，就视为静态内容了。 2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</code></pre></li><li><p>v-pre指令：</p><pre><code> 1.跳过其所在节点的编译过程。 2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</code></pre></li></ol><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><ol><li><p>定义语法：</p><p> (1).局部指令：</p><pre><code>         new Vue(&#123;                                    new Vue(&#123;             directives:&#123;指令名:配置对象&#125;   或           directives&#123;指令名:回调函数&#125;         &#125;)                                             &#125;)</code></pre><p> (2).全局指令：</p><pre><code>         Vue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)</code></pre></li><li><p>配置对象中常用的3个回调：<br> (1)bind：指令与元素成功绑定时调用。<br> (2)inserted：指令所在元素被插入页面时调用。<br> (3)update：指令所在模板结构被重新解析时调用。</p><blockquote><p>备注：<br> 1.指令定义时不加v-，但使用时要加v-；<br> 2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。</p></blockquote></li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li><p>又名：生命周期回调函数、生命周期函数、生命周期钩子。</p></li><li><p>是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。</p></li><li><p>生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p></li><li><p>生命周期函数中的this指向是vm 或 组件实例对象。</p></li><li><p>常用的生命周期钩子：</p><ol><li>mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</li><li>beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</li></ol></li><li><p>关于销毁Vue实例</p><ol><li>销毁后借助Vue开发者工具看不到任何信息。</li><li>销毁后自定义事件会失效，但原生DOM事件依然有效。</li><li>一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Promise笔记</title>
      <link href="/2022/10/24/Promise/"/>
      <url>/2022/10/24/Promise/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise笔记"><a href="#Promise笔记" class="headerlink" title="Promise笔记"></a>Promise笔记</h1><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><ul><li>fs 文件操作<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFile</span>(<span class="string">&#x27;./index.html&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li>数据库操作</li><li>Ajax<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">get</span>(<span class="string">&#x27;/server&#x27;</span>,<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li>定时器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Promise的状态改变"><a href="#Promise的状态改变" class="headerlink" title="Promise的状态改变"></a>Promise的状态改变</h2><p>实例对象中的一个属性 [PromiseState]</p><ul><li>pending 未决定的</li><li>resolved / fullfilled 成功</li><li>rejected 失败</li></ul><ol><li>pending 变为 resolved</li><li>pending 变为 rejected</li></ol><blockquote><p>说明：只有这两种状态，且一个 promise 对象只能改变一次<br>      无论变为成功还是失败，都会有一个结果数据<br>      成功的结果数据一般称为 value，失败的结果数据一般称为 reason</p></blockquote><h2 id="Promise-对象的值"><a href="#Promise-对象的值" class="headerlink" title="Promise 对象的值"></a>Promise 对象的值</h2><p>实例对象中的另一个属性 [PromiseResult]<br>保存着异步任务 [成功/失败] 的结果</p><ul><li>resolve</li><li>reject</li></ul><h2 id="Promise-Api"><a href="#Promise-Api" class="headerlink" title="Promise  Api"></a>Promise  Api</h2><ol><li><p>Promise 构造函数: Promise(executor){}</p><ol><li>executor 函数： 执行器 (resolve,reject)=&gt;{}</li><li>resolve 函数：内部定义成功时调用的函数 value=&gt;{}</li><li>reject 函数：内部定义失败时调用的函数 reason=&gt;{}<blockquote><p>说明：executor会在Promise内部立即同步调用，异步操作在执行器中执行</p></blockquote></li></ol></li><li><p>Promise.prototype.then 方法：(onResolved,onRejected)=&gt;{}</p><ol><li>onResolved函数：成功的回调 value=&gt;{}</li><li>onRejected函数：失败的回调 reason=&gt;{}<blockquote><p>说明：指定用于得到成功value的成功回调和用于得到失败回调返回一个新的promise对象</p></blockquote></li></ol></li><li><p>Promise.prototype.catch 方法：(onRejected)=&gt;{}<br>onRejected函数：失败的回调 reason=&gt;{}</p></li><li><p>Promise.resolve 方法：(value)=&gt;{}<br>value: 成功的数据或promise 对象</p><ol><li>如果传入的参数为：非Promise类型的对象，则返回的结果为成功的promise对象</li><li>如果传入的参数为：Promise对象，则参数的结果决定了 resolve 的结果<blockquote><p>说明：返回一个成功/失败的promise对象</p></blockquote></li></ol></li><li><p>Promise.reject 方法：(reason)=&gt;{}<br>reason: 失败的原因</p><blockquote><p>说明：返回一个失败的promise对象</p></blockquote></li><li><p>Promise.all 方法：(promises)={}<br>promises：包含 n个 promise 的数组</p><blockquote><p>说明：返回一个新的promise，只有所有的promise都成功才成功，只要有一个失败了就直接失败</p></blockquote></li><li><p>Promise.race 方法：(promises)={}<br> promises：包含 n个 promise 的数组</p><blockquote><p>说明：返回一个新的promise，第一个完成的promise的结果状态就是最终的结果状态</p></blockquote></li></ol><h2 id="Promise-的几个关键问题"><a href="#Promise-的几个关键问题" class="headerlink" title="Promise 的几个关键问题"></a>Promise 的几个关键问题</h2><ol><li><p>如何改变promise的状态？</p><ol><li>resolve(value)：如果当前是 pending 就会变为 resolved</li><li>reject(reason)：如果当前是 pending 就会变为 rejected</li><li>抛出异常(throw)：如果当前是 pending 就会变为 rejected</li></ol></li><li><p>一个promise指定多个成功/失败回调函数，都会调用吗？<br>当 promise 改变为对应状态时都会调用</p></li><li><p>改变promise状态和指定回调函数谁先谁后？</p><ol><li>都有可能，正常情况下是先指定回调再改变状态，但也可以先改变状态再指定回调</li><li>如何先改状态再指定回调？<br>(1). 在执行器中直接调用 resolve()/reject()<br>(2). 延迟更长时间才调用then()</li><li>什么时候才能得到数据？<br>(1). 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据<br>(2). 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</li></ol></li><li><p>Promise.then()返回的新 promise 的结果状态由什么决定？</p><ol><li>简单表达：由 then()指定的回调函数执行的结果决定</li><li>详细描述:<br>(1). 如果抛出异常，新promise变为rejected，reason为抛出对的异常<br>(2). 如果返回的是非promise的任意值，新promise变为resolved，value为返回值<br>(3). 如果返回的是另一个promise，此promise的结果就会成为新promise的结果</li></ol></li><li><p>Promise 如何串连多个操作任务？</p><ol><li>promise 的 then()返回一个新的 promise ，可以开成 then()的链式调用</li><li>通过 then 的链式调用串连多个同步/异步任务</li></ol></li><li><p>Promise异常穿透？</p><ol><li>当使用 promise 的 then 链式调用时，可以在最后指定失败的回调</li><li>前面任何操作出了异常，都会传到最后失败的回调中处理</li></ol></li><li><p>中断 promise 链？</p><pre><code> 有且只有一个方式： `return new Promise(()=&gt;&#123;&#125;)`</code></pre><ol><li>当使用 promise 的then 链式调用时，在中间中断，不再调用后面的回调函数</li><li>办法：在回调函数中返回一个pending 状态的 promise对象</li></ol></li></ol><h2 id="async-与-await"><a href="#async-与-await" class="headerlink" title="async 与 await"></a>async 与 await</h2><ol><li><p>async 函数</p><ol><li>函数的返回值为 promise 对象</li><li>promise 对象的结果由 async 函数执行的返回值决定</li></ol></li><li><p>await 表达式</p><ol><li>await 右侧的表达式一般为 promise 对象，但也可以是其他的值</li><li>如果表达式是 promise 对象，await 返回的是promise成功的值</li><li>如果表达式是其他值，直接将此值作为 await 的返回值<blockquote><p>注意：<br>1.await 必须写在 async 函数中，但async函数中可以没有 await<br>2.如果 await 的promise 失败了，就会抛出异常，需要通过try…catch捕获处理</p></blockquote></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git 常用命令</title>
      <link href="/2022/10/24/gir%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/10/24/gir%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr><tr><td>git reset –hard HEAD^</td><td>回退一个版本</td></tr></tbody></table><h2 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git branch -r</td><td>列出所有远程分支</td></tr><tr><td>git branch -d 分支名</td><td>删除分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git checkout -b 分支名</td><td>新建一个分支并切换到该分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr><tr><td>git branch -dr [remote/branch]</td><td>删除远程分支</td></tr><tr><td>git push origin –delete 分支名</td><td>删除远程分支</td></tr></tbody></table><h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><h2 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h2><pre><code>ssh-keygen -t rsa -C 邮箱地址</code></pre><h2 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>cd</td><td>改变目录</td></tr><tr><td>cd ..</td><td>回退到上一个目录，直接cd进入默认目录</td></tr><tr><td>pwd</td><td>显示当前所在的目录路径</td></tr><tr><td>ls(ll)</td><td>都是列出当前目录中的所有文件，只不过ll列出的内容更为详细</td></tr><tr><td>touch</td><td>新建一个文件如touch index.js就会在当前目录下新建一个index.js文件</td></tr><tr><td>rm</td><td>删除一个文件,rm index.js 就会把index.js文件删除</td></tr><tr><td>mkdir</td><td>新建一个目录，就是新建一个文件夹</td></tr><tr><td>rm -r</td><td>删除一个文件夹, rm -r src,删除src目录</td></tr><tr><td>mv</td><td>移动文件，mv index.html src， index.html是我们要移动的文件, src是目标文件夹</td></tr><tr><td>reset</td><td>重新初始化终端/清屏</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>history</td><td>查看命令历史</td></tr><tr><td>help</td><td>帮助</td></tr><tr><td>exit</td><td>退出</td></tr><tr><td>#</td><td>表示注释</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
